#!/usr/bin/env perl6

use lib 'lib';
use ICFP;
use Data::Dump::Tree;

say "Started!";

# Get the current status, don't use cache
my $use-cache = !%*ENV<NOCACHE>.Bool;
my $status-list = api-call('snapshot/list', use-cache => $use-cache);

# The lastmost one is the one we want
my $status-hash = $status-list<snapshots>[*-1]<snapshot_hash>;
say "Loading contest state $status-hash";
my $game-state = get-blob($status-hash);

# Get the list of problems
my @problem_hashes = $game-state<problems>.list;
my @problems;
my %problem_by_id;

say "Loading problems";
for @problem_hashes.sort(*<problem_id> <=> *<problem_id>) -> $problem_hash {
  my $problem-spec = get-blob($problem_hash<problem_spec_hash>, :!decode-json);
  %problem_by_id{$problem_hash<problem_id>} = $problem_hash;
  %problem_by_id{$problem_hash<problem_id>}<spec> = $problem-spec;
  push @problems, $problem-spec;
}

multi MAIN("ls") {
  say "ID\tsize\tssize\thash";
  for @problem_hashes.sort(*<problem_id> <=> *<problem_id>) -> $problem_hash {
    say $problem_hash<problem_id problem_size solution_size problem_spec_hash>.join("\t");
  }
}

multi MAIN("get-spec", $id) {
  say %problem_by_id{$id}<spec>;
}

multi MAIN("repl") {
  my $p = Problem::Grammar.parse-problem(@problems[0]);
  LREP::here;
}

multi MAIN("help") {
  say "hmm...";
}

multi MAIN("send-all-trivial") {
  my $boring-solution = q:to/END/;
    4
    0,0
    0,1
    1,1
    1,0
    1
    4 0 1 2 3
    0,0
    0,1
    1,1
    1,0
    END

  for @problem_hashes -> $problem_hash {
    my $id = $problem_hash<problem_id>;
    if $id > 1000 {
      say "Sending $id";
      send-solution($id, $boring-solution);
    }
  }
}

multi MAIN("send-semi-trivial") {
  my $count = 1;
  for @problem_hashes.sort(*<problem_id> <=> *<problem_id>) -> $problem_hash {
    $count++;
    my $id = $problem_hash<problem_id>;
    my $solution = shifted-solution( $problem_hash<spec> );
    say "Sending $id";
    send-solution($id, $solution);
    if ( $count == 1000 ) {
        say "Sent 1000. Quitting.\n";
        last;
    }
  }
}

sub dist($a, $b) {
  my ($x1, $y1) = $a;
  my ($x2, $y2) = $b;
  sqrt( ($x2 - $x1)**2 + ($y2 - $y1)**2 );
}

sub dot($a, $b) {
  my ($x1, $y1) = $a;
  my ($x2, $y2) = $b;
  $x1*$x2 + $y1*$y2;
}

sub angle($a, $b, $c) {
  my $b-fixed = ($b[0] - $a[0], $b[1] - $a[1]);
  my $c-fixed = ($c[0] - $a[0], $c[1] - $a[1]);
  my $dist1 = dist($a, $b);
  my $dist2 = dist($a, $c);
  my $dot1 = dot($b-fixed, $c-fixed);
  acos( $dot1 / ($dist1 * $dist2) );
}

multi MAIN("oragami") {
  my $g = Oragami.new;
  # $p.split-on( (0, <1/2>), (1, <1/2>) );

  my $p = $g.facets[0].polygon;
  my @polygons = $p.split-on( (1, <1/2>), (0, <1/2>) );
  # my @polygons = $p.split-on( (0, <1/2>), (1, <1/2>) );
  # my @polygons = $p.split-on( (<1/2>, 0), (<1/2>, 1) );
  # my @polygons = $p.split-on( (0, 0), (1, 1) );
  # my @polygons = $p.split-on( (1, 1), (0,0) );
  my $image = Imager.new(xsize => 1000, ysize => 1000);
  $image.polyline( points => [ [0,0], [0,999], [999,999], [999,0], [0,0] ], color => 'red');
  for @polygons -> $polygon {
    $polygon.draw($image, 0, 0);
  }
  $image.flip(dir => 'v');
  $image.write(file => "out.png");
  $image.flip(dir => 'v');

  # (atan2(|$z-fixed) - atan2(|$b-fixed)) % (2*pi)

  LREP::here;

  # $g.fold( [0,1], [1,0] );
  $g.fold( [0.5,0], [0.5,1] );
  # say $g.score_for($p);
}

multi MAIN("all-images") {
    for %problem_by_id.kv -> $index, $problem {
        my $p = Problem::Grammar.parse-problem( $problem<spec> );

        my $image = Imager.new(xsize => 1000, ysize => 1000);
        $image.polyline( points => [ [0,0], [0,999], [999,999], [999,0], [0,0] ], color => 'red');
        $p.draw($image);
        $image.flip(dir => 'v');
        $image.write(file => "images/problem_$index.png");
    }
}

